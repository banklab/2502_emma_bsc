---
title: "R Notebook"
output: html_notebook
---
 

```{r}
setwd("~/Documents/GitHub/2502_emma_bsc")

#create a new environment
#conda_create("r-slendr")

#Specify which python environment I want to use
Sys.setenv(RETICULATE_PYTHON = "/Users/benutzerin/Library/r-miniconda/envs/r-slendr/bin/python")

library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()

#these 2 commands are for installing the packages tskit and pyslim into python. 
#conda_install("r-slendr", "tskit", channel = "conda-forge")
#conda_install("r-slendr", "pyslim", channel = "conda-forge")

#some other helpful packages:
#conda_install("r-slendr", "gsl", channel = "conda-forge")
#conda_install("r-slendr", "msprime", channel = "conda-forge")

#install.packages("remotes")  # if not already installed
library(remotes)

# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE

# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")

#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036 - you also have to tell pyslim to treat individuals as seperate sexes!
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = as.integer(100036))      

cat("Raw metadata for individual 0:\n")
print(ts$individual(as.integer(80))$metadata)


# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")


lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines

# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)

for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
  cat("Individual:", ind_id, "\n")
  nodes_python <- ts$individual(ind_id)$nodes
  str(nodes_python)  # How does reticulate show these? 
  nodes_r <- py_to_r(nodes_python)
  str(nodes_r)       # What does it look like after py_to_r()?
}


# Step A: Gather all node objects, explicitly call .tolist() in Python
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
  node_obj <- ts$individual(ind_id)$nodes
  
  # Convert the NumPy array (or array-like) to a pure Python list:
  node_obj$tolist()
})

# Step B: Now convert *that* entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)

# Step C: Flatten everything into one long R vector
node_ids <- unlist(all_node_lists_r)

# Step D: Finally, convert to integer
node_ids <- as.integer(node_ids)

cat("Final node IDs:", node_ids, "\n")

# 4) Simplify the tree sequence while preserving SLiM metadata:
# Note that by setting filter_populations=FALSE, we keep the original population table,
# and by setting keep_input_individuals=TRUE, pyslim preserves individual-level SLiM metadata (e.g., relatedness).
ts_filtered <- ts$simplify(
  samples = node_ids,
  filter_populations = FALSE,   # Keep original population IDs and table
  filter_individuals = TRUE,    # Remove individuals that are not in node_ids
)


# 5) dump the filtered tree sequence to a new file.
ts_filtered$dump("model2_filteredinds.trees")

# 6) Inspect filtered TS in R.
cat("Number of individuals in the filtered TS:", ts_filtered$num_individuals, "\n")
cat("Number of samples in the filtered TS:", ts_filtered$num_samples, "\n")


```
