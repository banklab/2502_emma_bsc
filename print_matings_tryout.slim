initialize() {
	initializeSLiMModelType("WF"); // means that population size can not change dynamically -> WF model
	//turning on pedigree tracking, as relatedness
	initializeSLiMOptions(keepPedigrees = T); // Track ancestry
	initializeMutationRate(1e-7); //defining mutation rate
	initializeMutationType("m1", 0.5, "f", 0.0); //mutation type m1 has dominance coefficient 0.5 and is neutral (fitness 0.0)
	initializeGenomicElementType("g1", m1, 1.0); //genomic element type g1 is initialized with mutation type m1 and base mutation rate
	initializeGenomicElement(g1, 0, 99999); //g1 has length 10'000 bases, maybe change -> second genomic element?
	initializeRecombinationRate(1e-7); // specifies recombination rate --> Try different recombination rates...
	
    initializeTreeSeq(); //this command enables me to read in the saved (output from earlier simulation) population

	initializeSex("A"); //creates males and females in the population
	
	//defineConstant("reps", repetition); //This helps me to run the model multiple times with a code block in R.
	//defineConstant("simID", "_seed =" + getSeed()); // create a variable that contains the seed of the run, to make it repeatable... This will be visible in the output file!
}
	

100001 early() {

	//This command uploads the saved file from a previous simulation into this model and sets those individuals as my p1
	sim.readFromPopulationFile("final_output.trees"); // p1 now exists, restored from file - those are my 16 saved individuals
	//sim.readFromPopulationFile("1000_1e-7_output.trees"); // p1 now exists, restored from file - those are my 1000 saved individuals
	 cat("popsize" + size(p1)  + "\n");    

}

100001: 100100 mateChoice() {

	females = subpop.individuals[subpop.individuals.sex == "F"]; // Get all females
	males = subpop.individuals[subpop.individuals.sex == "M"]; // Get all males


//With the mateChoice command i can specify a specific pattern for matings. This one is a non-random mating, selecting mates with the lowest relatedness. 
//for (f in seqLen(size(females))){
//mateChoice() {
//	females = subpop.individuals[subpop.individuals.sex == "F"]; // Get all females
//	males = subpop.individuals[subpop.individuals.sex == "M"]; // Get all males

	//if (individual.sex == "F" & size(males) > 0) {
//			for (f in seqLen(size(females))){

//			relatedness = males.relatedness(females[f]); // Compute relatedness to all males
				relatedness = males.relatedness(individual);
				for (i in seqLen(size(males))) {
   			cat("Female " + individual.index + " - Male " + males[i].index + " relatedness: " + relatedness[i] + "\n");
 				}		
		
			bestIndex = which(relatedness == min(relatedness)); // gives out all males which have lowest relatedness value for the specific female
			//cat("Best Index = " + bestIndex +  "\n");


	// Randomly shuffle individuals (sample command) to prevent bias - this line creates a new list where every male with the lowest index gets picked only once
    	shuffledInds = sample(males[bestIndex], size(males[bestIndex]), replace = F);
    
    //cat("shuffled individuals" + paste(shuffledInds)  + "\n");    
    
		bestMate = shuffledInds[0];
		
//	cat(">>> Female " + individual.index + " chooses Male " + bestMate.index +  " with relatedness " + relatedness[bestIndex] + " at generation " + sim.cycle + "\n");		
cat(">>> Female " + individual.index + " chooses Male " + bestMate.index +  " with relatedness " + bestMate.relatedness(individual) + " at generation " + sim.cycle + "\n");		
		
	//	females = females[females != individual];
	//	males = males[males != bestMate]; // Remove selected male from pool --> Test this maybe?
		//}
		
		return bestMate;
	//}

//	return NULL;
		
	
}


////Just uncomment this part to let pop size chage
//	newSize = asInteger(p1.individualCount * 1.1); //increase popsize every generation by the factor 1.1 with a carrying capacity of "newSize"
//	if (newSize >= 100) 
//	{
//			newSize = 100;
//	}	
//	p1.setSubpopulationSize(newSize);
//	


100001: 100100 early() {
	inds = p1.individuals;
   N = size(inds);
	totalRel = 0.0;
   count = 0;	
	
	for (i in seqLen(N - 1)) {
        for (j in seq(i + 1, N - 1)) {
            totalRel = totalRel + inds[i].relatedness(inds[j]); //sum up the relatedness over the whole population -> for every pair, the relatedness value is added and after divided by the number of pairs (count)
            count = count + 1;
        }
    }
    meanRel = (count > 0) ? (totalRel / count) else 0.0; //If the count is greater than 0, set meanRel to (totalRel/count), otherwise put it to 0
    het = calcHeterozygosity(p1.genomes); //Calculate the genomewide heterozygosity over the whole population (all genomes of p1)

	//Now i want the meanRel and the het printed out in a file for every generation. In the name of the file there should be the model name (relatedness_heterozygosity_nrnr_), the current repetition (1-10) as well as the seed for the current simulation. 
 //  writeFile("relatedness_heterozygosity_nrnr_" + "reps_" + reps + simID + ".txt", sim.cycle + "\t" + meanRel + "\t" + het + "\n", append=T);
 
     cat("popsize" + size(p1.individuals)  + "\n");    

 
}
