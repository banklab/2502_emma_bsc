# 3) Gather the node IDs for these individuals
# 1) Gather all node lists from Python into an R list
node_list_python <- lapply(individuals_to_keep, function(x) ts$individual(x)$nodes)
# 2) Convert that entire list of Python objects to an R list
node_list_r <- py_to_r(node_list_python)
# 3) Flatten the nested list so it's a simple vector of node IDs
node_ids <- unlist(node_list_r)
# 4) Finally, convert to integer
node_ids <- as.integer(node_ids)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
library(remotes)
py_module_available("tskit")   # should be TRUE
# Import tskit
tskit <- import("tskit")
# Load the .trees file
ts <- tskit$load("model2.trees")
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# 3) Gather the node IDs for these individuals
# 1) Gather all node lists from Python into an R list
node_list_python <- lapply(individuals_to_keep, function(x) ts$individual(x)$nodes)
# 2) Convert that entire list of Python objects to an R list
node_list_r <- py_to_r(node_list_python)
# 3) Flatten the nested list so it's a simple vector of node IDs
node_ids <- unlist(node_list_r)
# 4) Finally, convert to integer
node_ids <- as.integer(node_ids)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
library(remotes)
py_module_available("tskit")   # should be TRUE
# Import tskit
tskit <- import("tskit")
# Load the .trees file
ts <- tskit$load("model2.trees")
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# Step A: Build a list of nodes in Python space
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
ts$individual(ind_id)$nodes
})
# Step B: Convert that entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)
# Now 'all_node_lists_r' should be an R list,
# whose elements are each a small integer vector (one for each individual).
str(all_node_lists_r)  # check the structure
# Step C: Flatten everything into one long vector
node_ids <- unlist(all_node_lists_r)
# Step D: Finally convert to integer
node_ids <- as.integer(node_ids)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
library(remotes)
py_module_available("tskit")   # should be TRUE
# Import tskit
tskit <- import("tskit")
# Load the .trees file
ts <- tskit$load("model2.trees")
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# Step A: Gather all node objects, explicitly call .tolist() in Python
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
node_obj <- ts$individual(ind_id)$nodes
# Convert the NumPy array (or array-like) to a pure Python list:
node_obj$tolist()
})
# Step B: Now convert *that* entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)
# Step C: Flatten everything into one long R vector
node_ids <- unlist(all_node_lists_r)
# Step D: Finally, convert to integer
node_ids <- as.integer(node_ids)
cat("Final node IDs:", node_ids, "\n")
# 4) Use simplify to keep just those nodes (and the relevant ancestral nodes).
ts_filtered <- ts$simplify(node_ids)
# 5) Optionally, dump the filtered tree sequence to a new file.
ts_filtered$dump("model2_filteredinds.trees")
# 6) Inspect your filtered TS in R if desired.
cat("Number of individuals in the filtered TS:", ts_filtered$num_individuals, "\n")
cat("Number of samples in the filtered TS:", ts_filtered$num_samples, "\n")
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
library(remotes)
py_module_available("tskit")   # should be TRUE
# Import tskit
tskit <- import("tskit")
# Load the .trees file
ts <- tskit$load("model2.trees")
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# Step A: Gather all node objects, explicitly call .tolist() in Python
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
node_obj <- ts$individual(ind_id)$nodes
# Convert the NumPy array (or array-like) to a pure Python list:
node_obj$tolist()
})
# Step B: Now convert *that* entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)
# Step C: Flatten everything into one long R vector
node_ids <- unlist(all_node_lists_r)
# Step D: Finally, convert to integer
node_ids <- as.integer(node_ids)
cat("Final node IDs:", node_ids, "\n")
# 4) Use simplify to keep just those nodes (and the relevant ancestral nodes).
ts_filtered <- ts$simplify(
samples = node_ids,
filter_populations = FALSE,  # keep original pop table
filter_individuals = TRUE    # remove individuals not in node_ids
)
# 5) Optionally, dump the filtered tree sequence to a new file.
ts_filtered$dump("model2_filteredinds.trees")
# 6) Inspect your filtered TS in R if desired.
cat("Number of individuals in the filtered TS:", ts_filtered$num_individuals, "\n")
cat("Number of samples in the filtered TS:", ts_filtered$num_samples, "\n")
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim is available (should return TRUE)
py_module_available("pyslim")
# Import pyslim (which builds on tskit but preserves SLiM metadata)
pyslim <- import("pyslim")
# Load the SLiM .trees file via pyslim to keep SLiM metadata like relatedness
ts <- pyslim$load("model2.trees")
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim is available (should return TRUE)
py_module_available("pyslim")
# Import pyslim (which builds on tskit but preserves SLiM metadata)
pyslim <- import("pyslim")
# Load the SLiM .trees file via pyslim to keep SLiM metadata like relatedness
ts <- pyslim.load("model2.trees")
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = 100036)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = as.integer(100036))
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# Step A: Gather all node objects, explicitly call .tolist() in Python
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
node_obj <- ts$individual(ind_id)$nodes
# Convert the NumPy array (or array-like) to a pure Python list:
node_obj$tolist()
})
# Step B: Now convert *that* entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)
# Step C: Flatten everything into one long R vector
node_ids <- unlist(all_node_lists_r)
# Step D: Finally, convert to integer
node_ids <- as.integer(node_ids)
cat("Final node IDs:", node_ids, "\n")
# 4) Simplify the tree sequence while preserving SLiM metadata:
# Note that by setting filter_populations=FALSE, we keep the original population table,
# and by setting keep_input_individuals=TRUE, pyslim preserves individual-level SLiM metadata (e.g., relatedness).
ts_filtered <- ts$simplify(
samples = node_ids,
filter_populations = FALSE,   # Keep original population IDs and table
filter_individuals = TRUE,    # Remove individuals that are not in node_ids
keep_input_individuals = TRUE # Preserve SLiM metadata (including relatedness)
)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = as.integer(100036))
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# Step A: Gather all node objects, explicitly call .tolist() in Python
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
node_obj <- ts$individual(ind_id)$nodes
# Convert the NumPy array (or array-like) to a pure Python list:
node_obj$tolist()
})
# Step B: Now convert *that* entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)
# Step C: Flatten everything into one long R vector
node_ids <- unlist(all_node_lists_r)
# Step D: Finally, convert to integer
node_ids <- as.integer(node_ids)
cat("Final node IDs:", node_ids, "\n")
# 4) Simplify the tree sequence while preserving SLiM metadata:
# Note that by setting filter_populations=FALSE, we keep the original population table,
# and by setting keep_input_individuals=TRUE, pyslim preserves individual-level SLiM metadata (e.g., relatedness).
ts_filtered <- ts$simplify(
samples = node_ids,
filter_populations = FALSE,   # Keep original population IDs and table
filter_individuals = TRUE,    # Remove individuals that are not in node_ids
)
# 5) dump the filtered tree sequence to a new file.
ts_filtered$dump("model2_filteredinds.trees")
# 6) Inspect filtered TS in R.
cat("Number of individuals in the filtered TS:", ts_filtered$num_individuals, "\n")
cat("Number of samples in the filtered TS:", ts_filtered$num_samples, "\n")
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036 - you also have to tell pyslim to treat individuals as seperate sexes!
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = as.integer(100036), separate_sexes = TRUE)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036 - you also have to tell pyslim to treat individuals as seperate sexes!
ts <- tskit$load("model2.trees")
# For example, check the metadata for individual 0
ind0_meta <- ts$individual(0)$metadata
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
tskit <- import("tskit")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036 - you also have to tell pyslim to treat individuals as seperate sexes!
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = as.integer(100036))
# Now I have a Python object 'ts' that I can use in R
print(ts)
cat("Total individuals:", ts$num_individuals, "\n")
lines <- readLines("model2_individuals.txt")
lines <- lines[lines != ""]
lines
# Now convert to integers
individuals_to_keep <- as.integer(lines)
individuals_to_keep
# Check
#range(individuals_to_keep)
for (ind_id in individuals_to_keep[1:5]) {  # just look at a few
cat("Individual:", ind_id, "\n")
nodes_python <- ts$individual(ind_id)$nodes
str(nodes_python)  # How does reticulate show these?
nodes_r <- py_to_r(nodes_python)
str(nodes_r)       # What does it look like after py_to_r()?
}
# Step A: Gather all node objects, explicitly call .tolist() in Python
all_node_lists_py <- lapply(individuals_to_keep, function(ind_id) {
node_obj <- ts$individual(ind_id)$nodes
# Convert the NumPy array (or array-like) to a pure Python list:
node_obj$tolist()
})
# Step B: Now convert *that* entire list-of-lists from Python into R objects
all_node_lists_r <- py_to_r(all_node_lists_py)
# Step C: Flatten everything into one long R vector
node_ids <- unlist(all_node_lists_r)
# Step D: Finally, convert to integer
node_ids <- as.integer(node_ids)
cat("Final node IDs:", node_ids, "\n")
# 4) Simplify the tree sequence while preserving SLiM metadata:
# Note that by setting filter_populations=FALSE, we keep the original population table,
# and by setting keep_input_individuals=TRUE, pyslim preserves individual-level SLiM metadata (e.g., relatedness).
ts_filtered <- ts$simplify(
samples = node_ids,
filter_populations = FALSE,   # Keep original population IDs and table
filter_individuals = TRUE,    # Remove individuals that are not in node_ids
)
# 5) dump the filtered tree sequence to a new file.
ts_filtered$dump("model2_filteredinds.trees")
# 6) Inspect filtered TS in R.
cat("Number of individuals in the filtered TS:", ts_filtered$num_individuals, "\n")
cat("Number of samples in the filtered TS:", ts_filtered$num_samples, "\n")
#Load the .trees file with tskit, then annotate with pyslim to preserve SLiM metadata like relatedness
#With pylim it is not possible to load the .tree file...
#To use pyslim, i also have to add the informations of my slim model - it is a WF model and ends at tick 100036 - you also have to tell pyslim to treat individuals as seperate sexes!
ts <- tskit$load("model2.trees")
ts <- pyslim$annotate(ts, model_type = "WF", tick = as.integer(100036))
cat("Raw metadata for individual 0:\n")
print(ts$individual(0)$metadata)
print(ts$individual(as.integer(0))$metadata)
print(ts$individual(as.integer(80))$metadata)
packageVersion("reticulate")
#install.packages("reticulate")
library(reticulate)
#create a new environment
conda_create("r-slendr")
use_condaenv("r-slendr", required = TRUE)
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
packageVersion("reticulate")
#install.packages("reticulate")
library(reticulate)
#create a new environment
conda_create("r-slendr")
use_condaenv("r-slendr", required = TRUE)
#install.packages("reticulate")
library(reticulate)
#create a new environment
conda_create("r-slendr")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
setwd("~/Documents/GitHub/2502_emma_bsc")
Sys.setenv(RETICULATE_PYTHON = "/Users/benutzerin/Library/r-miniconda/envs/r-slendr/bin/python")
library(reticulate)
use_condaenv("r-slendr", required = TRUE)
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
#use_condaenv("r-slendr", required = TRUE)
conda activate ("r-slendr")
setwd("~/Documents/GitHub/2502_emma_bsc")
library(reticulate)
#use_condaenv("r-slendr", required = TRUE)
py_config()
#install.packages("remotes")  # if not already installed
library(remotes)
# Check that pyslim and tskit are available (should return TRUE)
py_module_available("pyslim")
py_module_available("tskit")   # should be TRUE
# Import pyslim (which builds on tskit but preserves SLiM metadata) and tskit
pyslim <- import("pyslim")
